# Vivado Clock Connection Fix - Based on Vlad's Response

**Date:** February 26, 2025  
**Author:** Mbatshi Jerry Junior Mbulawa  
**Source:** Email response from Vlad

---

## The Problem (What We Were Doing Wrong)

We were trying to connect:
```
Zynq pl_clk0 → RF Data Converter adc0_clk input
```

This failed with: **"No matching connections found for 'adc0_clk' interface"**

---

## The Solution (What Vlad Explained)

### Key Insight from Vlad:

> "The easiest (and correct) way to achieve it is to **feed clk_adc0 to the PLL(MMCX) for it to generate s_axi_aclk** with a required frequency."

### Understanding the RF Data Converter Clocks

The RF Data Converter has **TWO different clock ports**:

1. **`adc0_clk` (INPUT)** — Reference clock going INTO the RF Data Converter
   - This drives the internal PLL
   - Can come from Zynq `pl_clk0`
   - This is what we were trying to connect

2. **`clk_adc0` (OUTPUT)** — Clock coming OUT of the RF Data Converter
   - Generated by the ADC core
   - **Synchronous to the ADC sample clock**
   - This is what should drive your processing chain

---

## The Correct Clock Architecture

```
┌─────────────────────┐
│  Zynq UltraScale+   │
│                     │
│  pl_clk0 (100 MHz) ─┼──┐
└─────────────────────┘  │
                         │ Reference clock
                         ▼
┌──────────────────────────────────────┐
│  RF Data Converter                   │
│                                      │
│  adc0_clk (INPUT) ◄──────────────────┤
│         │                            │
│         ▼ (Internal PLL)             │
│                                      │
│  clk_adc0 (OUTPUT) ─────────────────┼──┐
└──────────────────────────────────────┘  │
                                          │ ADC-synchronous clock
                                          ▼
                    ┌─────────────────────────────────┐
                    │  Clock Wizard (MMCM/PLL)        │
                    │                                 │
                    │  Input: clk_adc0                │
                    │  Output: s_axi_aclk (250 MHz)   │
                    └────────────┬────────────────────┘
                                 │ Generated processing clock
                ┌────────────────┼────────────────┐
                │                │                │
                ▼                ▼                ▼
         ┌──────────┐    ┌──────────┐    ┌──────────┐
         │   FFT    │    │   DMA    │    │  FIFO    │
         │   aclk   │    │   aclk   │    │   clk    │
         └──────────┘    └──────────┘    └──────────┘
```

---

## Why This Architecture Is Necessary

### Vlad's Critical Warning:

> "If ADC sampling clock and s_axi_aclk come from different sources (oscillators) then inevitably they will **drift**, FIFO will **underflow or overflow** and you will start **losing or duplicating samples**."

**What this means:**
- The ADC samples at its own rate (e.g., 4915.2 MSPS)
- Your processing blocks (FFT, DMA) run on a different clock
- These clocks **must be frequency-locked** to each other
- Otherwise: data corruption, dropped samples, duplicated samples

**The Clock Wizard (MMCM) ensures:**
- The processing clock is derived from the ADC clock
- No frequency drift between domains
- Sample integrity preserved

---

## Step-by-Step Vivado Fix

### Step 1: Connect Reference Clock to RF Data Converter Input

This part we already attempted correctly:

1. **Zynq `pl_clk0`** → **RF Data Converter `adc0_clk` input**

If this connection still fails with "no matching interface":
- Try the external port workaround from our previous attempts
- OR use the Clocking Wizard as an intermediary
- OR manually edit the TCL (we tried this)

**Note:** This connection might actually already be working, or the RF Data Converter has an internal default. The critical part is Step 2.

---

### Step 2: Use RF Data Converter Output Clock

1. Look at the **RF Data Converter block**
2. Find the **`clk_adc0` OUTPUT** port (right side of block)
   - This is different from `adc0_clk` input!
3. This clock is the one generated by the ADC core

---

### Step 3: Add Clock Wizard (CRITICAL)

1. Press **Ctrl+I**
2. Type: `clocking wizard`
3. Add **Clocking Wizard** IP to your design

4. **Configure the Clock Wizard:**
   - **Input Clock**: Connect from RF Data Converter `clk_adc0` output
   - **Input Frequency**: The frequency of `clk_adc0` (check RF Data Converter config)
   - **Output Clock 1**: Set to desired frequency (e.g., 250 MHz for FFT)
   - **Output Clock 2** (optional): Additional frequency if needed

5. **Enable Features:**
   - **Locked output**: Check this box (important!)
   - **Reset**: Active low

---

### Step 4: Connect Clock Wizard Output to Processing Blocks

From the Clock Wizard output (`clk_out1`):

1. **Connect to FFT:**
   - `clk_wiz_0/clk_out1` → `xfft_0/aclk`

2. **Connect to DMA:**
   - `clk_wiz_0/clk_out1` → `axi_dma_0/m_axi_s2mm_aclk`
   - `clk_wiz_0/clk_out1` → `axi_dma_0/s_axi_lite_aclk`

3. **Connect to any FIFOs** (if you add them later for clock domain crossing)

4. **Connect `locked` signal** to reset management:
   - `clk_wiz_0/locked` → `rst_ps8_0_99M/dcm_locked`

---

### Step 5: Validate Design

1. Press **F6** (Validate Design)
2. **Expected result:** All clock errors should be resolved
3. The design should now pass validation

---

## Clock Domain Crossing (Advanced)

Vlad also mentioned:

> "You will need to cross clock domains from your ADC sampling clocks to CPU clocks. You can do it at different points, for example **after FFT and before DMA by using a FIFO**."

### When to Add Clock Domain Crossing FIFO:

If you want the DMA to run on a completely independent clock (e.g., the PS clock):

```
FFT (ADC clock domain) → FIFO (async) → DMA (PS clock domain)
```

**How to implement:**
1. Add **AXI4-Stream Data FIFO** IP
2. Configure as **asynchronous** (different input/output clocks)
3. Connect:
   - Input side: FFT output + ADC-derived clock
   - Output side: DMA input + PS clock

**For now:** Don't add this. Keep everything on the ADC-derived clock as shown above. Add FIFO only if you encounter timing issues or if you specifically need the DMA on PS clock.

---

## Simulation Testing (Vlad's Recommendation)

Vlad strongly recommends:

> "I strongly advise to **simulate** a whole or reduced system by writing a simple CPU code to just read the data from ADC and check it integrity."

**How to do this:**
1. In Vivado, after completing block design
2. Go to **Flow Navigator → Simulation → Run Simulation → Run Behavioral Simulation**
3. Write a simple testbench in Verilog/VHDL that:
   - Generates test data
   - Feeds it through your pipeline
   - Checks data integrity at DMA output
4. Verify no samples are dropped or duplicated

**For MSc timeline:** This is optional/advanced. Focus on getting hardware working first.

---

## Summary: What to Change in Your Block Diagram

### Current (Broken):
```
Zynq pl_clk0 ─X─ (trying to connect) ─X─ RF Data Converter adc0_clk
FFT aclk ← (no connection or wrong clock)
```

### Corrected:
```
Zynq pl_clk0 → RF Data Converter adc0_clk (input)
RF Data Converter clk_adc0 (output) → Clock Wizard → FFT aclk & DMA aclk
```

---

## Additional Notes from Vlad

### On Sample Rate Configuration:

> "To get 200Msps without band shifting you can set **ADC sample clock** to the desired frequency by programming on-board PLLs. For example, **3.2GHz ADC sampling clock with 16x decimation** will give you a required 200Msps rate."

**What this means for you:**
- You don't have to use 4915.2 MSPS
- You can configure the ADC tile to sample at 3.2 GHz
- Then use 16x decimation to get exactly 200 MSPS

**How to set ADC sample rate:**
1. In RF Data Converter configuration (System Clocking tab)
2. Set **Sampling Rate** for ADC Tile 224
3. Allowed range: 1 GHz to 5 GHz

---

### On DDC (Not Needed for RHINO):

Your supervisor said: *"The stuff Vlad was saying about the mixing I dont think we need."*

**Correct decision.** For RHINO:
- Direct sampling 60–85 MHz is fine
- No need for NCO/mixer/DDC
- Keep it simple: ADC → Decimation → FFT

---

## Next Steps

1. ✅ Open your Vivado project
2. ✅ Find the RF Data Converter **output** clock `clk_adc0`
3. ✅ Add Clock Wizard, connect `clk_adc0` as input
4. ✅ Connect Clock Wizard output to FFT and DMA
5. ✅ Validate design (F6)
6. ✅ If validation passes, proceed to synthesis
7. ✅ Generate bitstream
8. ✅ Test on hardware with Python

---

## Questions to Ask on Friday

1. **Do we want to change ADC sample rate to 3.2 GHz for cleaner decimation math?**
   - 3.2 GHz / 16 = 200 MSPS exactly
   - vs 4915.2 MHz / 16 = 307.2 MSPS (current)

2. **Do we need clock domain crossing FIFO, or is everything on ADC clock OK?**

3. **Priority: Vivado bitstream vs PFB in Python?**
   - Supervisor 1: Focus on Vivado + server/client
   - Supervisor 2: "PFB without decimation"

---

**End of Document**